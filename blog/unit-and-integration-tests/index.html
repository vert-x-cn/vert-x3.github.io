<!DOCTYPE html><html lang=en><head><title>Unit and Integration Tests</title><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta content="width=device-width,initial-scale=1" name=viewport><meta content="Eclipse Vert.x is a tool-kit for building reactive applications on the JVM." name=description><link href=https://vertx.tk/stylesheets/main.css media=screen rel=stylesheet><link href=https://vertx.tk/stylesheets/font-awesome.min.css media=screen rel=stylesheet><link href=https://vertx.tk/javascripts/styles/rainbow.min.css media=screen rel=stylesheet><!--[if lt IE 9]><script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script><![endif]--><link rel=apple-touch-icon sizes=57x57 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=https://vertx.tk/assets/favicons/vertx-favicon-7/apple-touch-icon-180x180.png><link rel=icon type=image/png href=https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://vertx.tk/assets/favicons/vertx-favicon-7/android-chrome-192x192.png sizes=192x192><link rel=icon type=image/png href=https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-96x96.png sizes=96x96><link rel=icon type=image/png href=https://vertx.tk/assets/favicons/vertx-favicon-7/favicon-16x16.png sizes=16x16><link rel=manifest href=https://vertx.tk/assets/favicons/vertx-favicon-7/manifest.json><link rel=mask-icon href=https://vertx.tk/assets/favicons/vertx-favicon-7/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#7d3194><meta name=msapplication-TileImage content=https://vertx.tk/assets/favicons/vertx-favicon-7/mstile-144x144.png><meta name=theme-color content=#ffffff><link href="https://fonts.googleapis.com/css?family=Ubuntu:400,500,700,400italic" rel=stylesheet type=text/css><link rel=alternate type=application/rss+xml title=RSS href=https://vertx.tk/feed.xml><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-30144458-1', 'auto');
    ga('create', 'UA-71153120-1', 'auto', 'tracker');
    ga('send', 'pageview');
    ga('tracker.send', 'pageview');</script><style>.page-link-to-github {
      position: relative;
      z-index: 1;
      display: inline-block;
      border: 1px solid #782B90;
      border-radius: 5px;
      color: #782B90;
      font-size: 12px;
      padding: 4px 10px;
      text-decoration: none;
      background-color: #ffffff;
    }
    .page-link-to-github:hover {
      color: #ffffff;
      border-color: #ffffff;
      background-color: #782B90;
    }

    .page-link-to-github .github-icon {
      position: absolute;
      display: inline-block;
      width: 20px;
      height: 20px;
      /*background-position: -50px 0*/
      background: url('https://vertx.tk/assets/github.png') no-repeat 0 0;
    }

    @media (-webkit-min-device-pixel-ratio: 2),(min-resolution:192dpi) {
      .page-link-to-github .github-icon {
        background-image:url('https://vertx.tk/assets/github@2x.png');
        background-size: 150px auto
      }
    }

    .page-link-to-github:hover .github-icon {
      /*background-position: 0 0*/
      background-position: -100px 0
    }
    .text {
      text-decoration: underline
    }
    .page-link-to-github .text {
      padding-left: 27px
    }
    .text {
      padding-right: 8px
    }
    .page-link-to-github {
      float: right;
      top: 4px
    }</style></head><body><a href="http://www.reactivemanifesto.org/" id=reactive-manifesto-banner><img style="border: 0; position: fixed; right: 0; top:0; z-index: 9000" src=https://d379ifj7s9wntv.cloudfront.net/reactivemanifesto/images/ribbons/we-are-reactive-black-right.png></a> <a id=skippy class="sr-only sr-only-focusable" href=#content><div class=container><span class=skiplink-text>Skip to main content</span></div></a><header class="navbar navbar-default navbar-static-top" id=top role=banner><div class=container><div class=navbar-header><button class="navbar-toggle collapsed" type=button data-toggle=collapse data-target=#vertx-navbar-collapse><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a href="https://vertx.tk/" class=navbar-brand><img alt=Brand src=https://vertx.tk/assets/logo-sm.png></a></div><nav class="collapse navbar-collapse" id=vertx-navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=http://start.vertx.io>Starter</a></li><li><a href="https://vertx.tk/download/">下载</a></li><li><a href="https://vertx.tk/docs/">文档</a></li><li><a href=https://github.com/vert-x3/wiki/wiki>维基</a></li><li><a href="https://vertx.tk/community/">社区</a></li><li><a href="https://vertx.tk/materials/">资料</a></li><li><a href="https://vertx.tk/blog/">博客</a></li></ul></nav></div></header><div class=container><div class="row blog"><article class="col-xs-12 blog-post"><h2 class=blog-post-title>Unit and Integration Tests</h2><p class=blog-post-meta>3rd August 2015 by <a href=http://github.com/cescoffier>cescoffier</a></p><article><h2 id=previously-in-introduction-to-vert-x->Previously in “introduction to vert.x”</h2><p>Let’s refresh our mind about what we developed so far in the <em>introduction to vert.x</em> series. In <a href="https://vertx.tk/blog/my-first-vert-x-3-application/">the first post</a>, we developed a very simple Vert.x 3 application, and saw how this application can be tested, packaged and executed. In <a href="https://vertx.tk/blog/vert-x-application-configuration/">the second post</a>, we saw how this application became configurable and how we can use a random port in test, and use another configurable port in production. Finally, the <a href="https://vertx.tk/blog/some-rest-with-vert-x/">previous post</a> has shown how to use vertx-web and how to implement a small REST API. However, we forgot an important task. We didn’t test the API. In this post we will increase the confidence we have on this application by implementing unit and integration tests.</p><p>The code of this post is available in the <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-4>post-4 branch</a> of the <a href=https://github.com/cescoffier/my-vertx-first-app>project</a>. The starting post, however is the code available in the <a href=https://github.com/cescoffier/my-vertx-first-app/tree/post-3>post-3 branch</a>.</p><h2 id=tests-tests-tests->Tests, Tests, Tests…</h2><p>This post is mainly about tests. We distinguish two types of tests: unit tests and integration tests. Both are equally important, but have different focus. Unit tests ensure that one <em>component</em> of your application, generally a class in the Java world, behaves as expected. The application is not tested as a whole, but pieces by pieces. Integration tests are more <em>black box</em> in the sense that the application is started and tested generally externally.</p><p>In this post we are going to start with some more unit tests as a warm up session and then focus on integration tests. If you already implemented integration tests, you may be a bit scared, and it makes sense. But don’t worry, with Vert.x there are no hidden surprises.</p><h2 id=warmup-some-more-unit-tests>Warmup: Some more unit tests</h2><p>Let’s start slowly. Remember in the first post we have implemented a unit test with <a href="http://vertx.io/docs/vertx-unit/java/">vertx-unit</a>. The test we did is dead simple:</p><ol><li>we started the application before the test</li><li>we checks that it replies “Hello”</li></ol><p>Just to refresh your mind, let’s have a look at the <a href=https://github.com/cescoffier/my-vertx-first-app/blob/post-4/src/test/java/io/vertx/blog/first/MyFirstVerticleTest.java>code</a></p><pre><code class="hljs java"><span class=hljs-annotation>@Before</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>setUp</span><span class=hljs-params>(TestContext context)</span> <span class=hljs-keyword>throws</span> IOException </span>{
  vertx = Vertx.vertx();
  ServerSocket socket = <span class=hljs-keyword>new</span> ServerSocket(<span class=hljs-number>0</span>);
  port = socket.getLocalPort();
  socket.close();
  DeploymentOptions options = <span class=hljs-keyword>new</span> DeploymentOptions()
      .setConfig(<span class=hljs-keyword>new</span> JsonObject().put(<span class=hljs-string>"http.port"</span>, port)
      );
  vertx.deployVerticle(MyFirstVerticle.class.getName(), options, context.asyncAssertSuccess());
}</code></pre><p>The <code>setUp</code> method is invoked before each test (as instructed by the <code>@Before</code> annotation). It, first, creates a new instance of Vert.x. Then, it gets a free port and then deploys our verticle with the right configuration. Thanks to the <code>context.asyncAssertSuccess()</code> it waits until the successful deployment of the verticle.</p><p>The <code>tearDown</code> is straightforward and just closes the Vert.x instance. It automatically un-deploys the verticles:</p><pre><code class="hljs java"><span class=hljs-annotation>@After</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>tearDown</span><span class=hljs-params>(TestContext context)</span> </span>{
  vertx.close(context.asyncAssertSuccess());
}</code></pre><p>Finally, our single test is:</p><pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>testMyApplication</span><span class=hljs-params>(TestContext context)</span> </span>{
  <span class=hljs-keyword>final</span> Async async = context.async();
  vertx.createHttpClient().getNow(port, <span class=hljs-string>"localhost"</span>, <span class=hljs-string>"/"</span>, response -&gt; {
    response.handler(body -&gt; {
      context.assertTrue(body.toString().contains(<span class=hljs-string>"Hello"</span>));
      async.complete();
    });
  });
 }</code></pre>It is only checking that the application replies "Hello" when we emit a HTTP request on `/`. Let's now try to implement some unit tests checkin that our web application and the REST API behave as expected. Let's start by checking that the `index.html` page is correctly served. This test is very similar to the previous one:<pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>checkThatTheIndexPageIsServed</span><span class=hljs-params>(TestContext context)</span> </span>{
  Async async = context.async();
  vertx.createHttpClient().getNow(port, <span class=hljs-string>"localhost"</span>, <span class=hljs-string>"/assets/index.html"</span>, response -&gt; {
    context.assertEquals(response.statusCode(), <span class=hljs-number>200</span>);
    context.assertEquals(response.headers().get(<span class=hljs-string>"content-type"</span>), <span class=hljs-string>"text/html"</span>);
    response.bodyHandler(body -&gt; {
      context.assertTrue(body.toString().contains(<span class=hljs-string>"&lt;title&gt;My Whisky Collection&lt;/title&gt;"</span>));
      async.complete();
    });
  });
}</code></pre><p>We retrieve the <code>index.html</code> page and check:</p><ol><li>it’s there (status code 200)</li><li>it’s a HTML page (content type set to “text/html”)</li><li>it has the right title (“My Whisky Collection”)</li></ol><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>Retrieving content</span><br><span class=content>As you can see, we can test the status code and the headers directly on the HTTP response, but ensure that the body is right, we need to retrieve it. This is done with a body handler that receives the complete body as parameter. Once the last check is made, we release the <code>async</code> by calling <code>complete</code>.</span></td></tr></tbody></table></div></p><p>Ok, great, but this actually does not test our REST API. Let’s ensure that we can add a bottle to the collection. Unlike the previous tests, this one is using <code>post</code> to <em>post</em> data to the server:</p><pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>checkThatWeCanAdd</span><span class=hljs-params>(TestContext context)</span> </span>{
  Async async = context.async();
  <span class=hljs-keyword>final</span> String json = Json.encodePrettily(<span class=hljs-keyword>new</span> Whisky(<span class=hljs-string>"Jameson"</span>, <span class=hljs-string>"Ireland"</span>));
  <span class=hljs-keyword>final</span> String length = Integer.toString(json.length());
  vertx.createHttpClient().post(port, <span class=hljs-string>"localhost"</span>, <span class=hljs-string>"/api/whiskies"</span>)
      .putHeader(<span class=hljs-string>"content-type"</span>, <span class=hljs-string>"application/json"</span>)
      .putHeader(<span class=hljs-string>"content-length"</span>, length)
      .handler(response -&gt; {
        context.assertEquals(response.statusCode(), <span class=hljs-number>201</span>);
        context.assertTrue(response.headers().get(<span class=hljs-string>"content-type"</span>).contains(<span class=hljs-string>"application/json"</span>));
        response.bodyHandler(body -&gt; {
          <span class=hljs-keyword>final</span> Whisky whisky = Json.decodeValue(body.toString(), Whisky.class);
          context.assertEquals(whisky.getName(), <span class=hljs-string>"Jameson"</span>);
          context.assertEquals(whisky.getOrigin(), <span class=hljs-string>"Ireland"</span>);
          context.assertNotNull(whisky.getId());
          async.complete();
        });
      })
      .write(json)
      .end();
}</code></pre><p>First we create the content we want to add. The server consumes JSON data, so we need a JSON string. You can either write your JSON document manually, or use the Vert.x method (<code>Json.encodePrettily</code>) as done here. Once we have the content, we create a <code>post</code> request. We need to configure some headers to be correctly read by the server. First, we say that we are sending JSON data and we also set the content length. We also attach a response handler very close to the checks made in the previous test. Notice that we can rebuild our object from the JSON document send by the server using the <code>JSON.decodeValue</code> method. It’s very convenient as it avoids lots of boilerplate code. At this point the request is not emitted, we need to write the data and call the <code>end()</code> method. This is made using <code>.write(json).end();</code>.</p><p>The order of the methods is important. You cannot <em>write</em> data if you don’t have a response handler configured. Finally don’t forget to call <code>end</code>.</p><p>So, let’s try this. You can run the test using:</p><pre><code class="hljs bash">mvn clean test</code></pre><p>We could continue writing more unit test like that, but it could become quite complex. Let’s see how we could continue our tests using integration tests.</p><h2 id=it-hurts>IT hurts</h2><p>Well, I think we need to make that clear, integration testing hurts. If you have experience in this area, can you remember how long did it take to setup everything correctly? I get new white hairs by just thinking about it. Why are integration tests more complicated? It’s basically because of the setup:</p><ol><li>We must start the application in a <em>close to production</em> way</li><li>We must then run the tests (and configure them to hit the right application instance)</li><li>We must stop the application</li></ol><p>That does not sound unconquerable like that, but if you need Linux, MacOS X and Windows support, it quickly get messy. There are plenty of great frameworks easing this such as <a href=http://arquillian.org>Arquillian</a>, but let’s do it without any framework to understand how it works.</p><h2 id=we-need-a-battle-plan>We need a battle plan</h2><p>Before rushing into the complex configuration, let’s think a minute about the tasks:</p><p><strong>Step 1 - Reserve a free port</strong> We need to get a free port on which the application can <em>listen</em>, and we need to inject this port in our integration tests.</p><p><strong>Step 2 - Generate the application configuration</strong> Once we have the free port, we need to write a JSON file configuring the application HTTP Port to this port.</p><p><strong>Step 3 - Start the application</strong> Sounds easy right? Well it’s not that simple as we need to launch our application in a background process.</p><p><strong>Step 4 - Execute the integration tests</strong> Finally, the central part, run the tests. But before that we should implement some integration tests. Let’s come to that later.</p><p><strong>Step 5 - Stop the application</strong> Once the tests have been executed, regardless if there are failures or errors in the tests, we need to stop the application.</p><p>There are multiple way to implement this plan. We are going to use a <em>generic</em> way. It’s not necessarily the better, but can be applied almost everywhere. The approach is tight to Apache Maven. If you want to propose an alternative using Gradle or a different tool, I will be happy to add your way to the post.</p><h2 id=implement-the-plan>Implement the plan</h2><p>As said above, this section is Maven-centric, and most of the code goes in the <a href=https://github.com/cescoffier/my-vertx-first-app/blob/post-4/pom.xml>pom.xml</a> file. If you never used the different Maven lifecycle phases, I recommend you to look at the <a href=https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html>introduction to the Maven lifecycle</a>.</p><p>We need to add and configure a couple of plugins. Open the <code>pom.xml</code> file and in the <code>&lt;plugins&gt;</code> section add:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>org.codehaus.mojo<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>build-helper-maven-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>1.9.1<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>reserve-network-port<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>reserve-network-port<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>process-sources<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>portNames</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>portName</span>&gt;</span>http.port<span class=hljs-tag>&lt;/<span class=hljs-title>portName</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>portNames</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span></code></pre><p>We use the <code>build-helper-maven-plugin</code> (a plugin to know if you are often using Maven) to pick up a free port. Once found, the plugin assigns the <code>http.port</code> variable to the picked port. We execute this plugin early in the build (during the <code>process-sources</code> phase), so we can use the <code>http.port</code> variable in the other plugin. This was for the first step.</p><p>Two actions are required for the second step. First, in the <code>pom.xml</code> file, just below the <code>&lt;build&gt;</code> opening tag, add:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>testResources</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>testResource</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>directory</span>&gt;</span>src/test/resources<span class=hljs-tag>&lt;/<span class=hljs-title>directory</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>filtering</span>&gt;</span>true<span class=hljs-tag>&lt;/<span class=hljs-title>filtering</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>testResource</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>testResources</span>&gt;</span></code></pre><p>This instructs Maven to <em>filter</em> resources from the <code>src/test/resources</code> directory. <em>Filter</em> means replacing placeholders by actual values. That’s exactly what we need as we now have the <code>http.port</code> variable. So create the <code>src/test/resources/my-it-config.json</code> file with the following content:</p><pre><code class="hljs javascript">{
  <span class=hljs-string>"http.port"</span>: ${http.port}
}</code></pre><p>This configuration file is similar to the one we did in previous posts. The only difference is the <code>${http.port}</code> which is the (default) Maven syntax for filtering. So, when Maven is going to process or file it will replace <code>${http.port}</code> by the selected port. That’s all for the second step.</p><p>The step 3 and 5 are a bit more tricky. We should start and stop the application. We are going to use the <code>maven-antrun-plugin</code> to achieve this. In the <code>pom.xml</code> file, below the <code>build-helper-maven-plugin</code>, add:</p><pre><code class="hljs xml"><span class=hljs-comment>&lt;!-- We use the maven-antrun-plugin to start the application before the integration tests
and stop them afterward --&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>maven-antrun-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>1.8<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>start-vertx-app<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>pre-integration-test<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>run<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>target</span>&gt;</span>
          <span class=hljs-comment>&lt;!--
          Launch the application as in 'production' using the fatjar.
          We pass the generated configuration, configuring the http port to the picked one
          --&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>exec</span> <span class=hljs-attribute>executable</span>=<span class=hljs-value>"${java.home}/bin/java"</span>
                <span class=hljs-attribute>dir</span>=<span class=hljs-value>"${project.build.directory}"</span>
                <span class=hljs-attribute>spawn</span>=<span class=hljs-value>"true"</span>&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"-jar"</span>/&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"${project.artifactId}-${project.version}-fat.jar"</span>/&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"-conf"</span>/&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"${project.build.directory}/test-classes/my-it-config.json"</span>/&gt;</span>
          <span class=hljs-tag>&lt;/<span class=hljs-title>exec</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>target</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>stop-vertx-app<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>post-integration-test<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>run<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-comment>&lt;!--
          Kill the started process.
          Finding the right process is a bit tricky. Windows command in in the windows profile (below)
          --&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>target</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>exec</span> <span class=hljs-attribute>executable</span>=<span class=hljs-value>"bash"</span>
                <span class=hljs-attribute>dir</span>=<span class=hljs-value>"${project.build.directory}"</span>
                <span class=hljs-attribute>spawn</span>=<span class=hljs-value>"false"</span>&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"-c"</span>/&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"ps ax | grep -Ei '[\-]DtestPort=${http.port}\s+\-jar\s+${project.artifactId}' | awk 'NR==1{print $1}' | xargs kill -SIGTERM"</span>/&gt;</span>
          <span class=hljs-tag>&lt;/<span class=hljs-title>exec</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>target</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span></code></pre><p>That’s a huge piece of XML, isn’t it ? We configure two executions of the plugin. The first one, happening in the <code>pre-integration-test</code> phase, executes a set of bash command to start the application. It basically executes:</p><pre><code class="hljs bash">java -jar my-first-app-<span class=hljs-number>1.0</span>-SNAPSHOT-fat.jar -conf .../my-it-config.json</code></pre><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>Is the fatjar created ?</span><br><span class=content>The fat jar embedding our application is created in the <code>package</code> phase, preceding the <code>pre-integration-test</code>, so yes, the fat jar is created.</span></td></tr></tbody></table></div></p><p>As mentioned above, we launch the application as we would in a production environment.</p><p>Once, the integration tests are executed (step 4 we didn’t look at it yet), we need to stop the application (so in the the <code>post-integration-test</code> phase). To close the application, we are going to invoke some shell magic command to find our process in with the <code>ps</code> command and send the <code>SIGTERM</code> signal. It is equivalent to:</p><pre><code class="hljs bash">ps
.... -&gt; find your process id
kill your_process_id -SIGTERM</code></pre><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>And Windows ?</span><br><span class=content>I mentioned it above, we want Windows to be supported and these commands are not going to work on Windows. Don’t worry, Windows configuration is below….</span></td></tr></tbody></table></div></p><p>We should now do the fourth step we (silently) skipped. To execute our integration tests, we use the <code>maven-failsafe-plugin</code>. Add the following plugin configuration to your <code>pom.xml</code> file:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>org.apache.maven.plugins<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>maven-failsafe-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>2.18.1<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>integration-test<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>verify<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>systemProperties</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>http.port</span>&gt;</span>${http.port}<span class=hljs-tag>&lt;/<span class=hljs-title>http.port</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>systemProperties</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span></code></pre><p>As you can see, we pass the <code>http.port</code> property as a system variable, so our tests are able to connect on the right port.</p><p>That’s all! Wow… Let’s try this (for windows users, you will need to be patient or to jump to the last section).</p><pre><code class="hljs bash">mvn clean verify</code></pre><p>We should not use <code>mvn integration-test</code> because the application would still be running. The <code>verify</code> phase is after the <code>post-integration-test</code> phase and will analyse the integration-tests results. Build failures because of integration tests failed assertions are reported in this phase.</p><h2 id=hey-we-don-t-have-integration-tests->Hey, we don’t have integration tests !</h2><p>And that’s right, we set up everything, but we don’t have a single integration test. To ease the implementation, let’s use two libraries: <a href="http://joel-costigliola.github.io/assertj/">AssertJ</a> and <a href=https://github.com/jayway/rest-assured>Rest-Assured</a>.</p><p>AssertJ proposes a set of assertions that you can chain and use fluently. Rest Assured is a framework to test REST API.</p><p>In the <code>pom.xml</code> file, add the two following dependencies just before <code>&lt;/dependencies&gt;</code>:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>dependency</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>com.jayway.restassured<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>rest-assured<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>2.4.0<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>scope</span>&gt;</span>test<span class=hljs-tag>&lt;/<span class=hljs-title>scope</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>dependency</span>&gt;</span>
<span class=hljs-tag>&lt;<span class=hljs-title>dependency</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>groupId</span>&gt;</span>org.assertj<span class=hljs-tag>&lt;/<span class=hljs-title>groupId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>assertj-core<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>2.0.0<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>scope</span>&gt;</span>test<span class=hljs-tag>&lt;/<span class=hljs-title>scope</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>dependency</span>&gt;</span></code></pre><p>Then, create the <code>src/test/java/io/vertx/blog/first/MyRestIT.java</code> file. Unlike unit test, integration test ends with <code>IT</code>. It’s a convention from the Failsafe plugin to distinguish unit (starting or ending with <em>Test</em>) from integration tests (starting or ending with _IT_). In the created file add:</p><pre><code class="hljs java"><span class=hljs-keyword>package</span> io.vertx.blog.first;

<span class=hljs-keyword>import</span> com.jayway.restassured.RestAssured;
<span class=hljs-keyword>import</span> org.junit.AfterClass;
<span class=hljs-keyword>import</span> org.junit.BeforeClass;

<span class=hljs-keyword>public</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>MyRestIT</span> </span>{

  <span class=hljs-annotation>@BeforeClass</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>void</span> <span class=hljs-title>configureRestAssured</span><span class=hljs-params>()</span> </span>{
    RestAssured.baseURI = <span class=hljs-string>"http://localhost"</span>;
    RestAssured.port = Integer.getInteger(<span class=hljs-string>"http.port"</span>, <span class=hljs-number>8080</span>);
  }

  <span class=hljs-annotation>@AfterClass</span>
  <span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>static</span> <span class=hljs-keyword>void</span> <span class=hljs-title>unconfigureRestAssured</span><span class=hljs-params>()</span> </span>{
    RestAssured.reset();
  }
}</code></pre><p>The methods annotated with <code>@BeforeClass</code> and <code>@AfterClass</code> are invoked once before / after all tests of the class. Here, we just retrieve the http port (passed as a system property) and we configure REST Assured.</p><p><div class="admonition-block note"><table><tbody><tr><td class=admonition-icon><i class="admonition-icon fa fa-comment"></i></td><td class=content><span class=title>Am I ready to serve ?</span><br><span class=content>You may need to wait in the <code>configureRestAssured</code> method that the HTTP server has been started. We recommend the <a href=https://github.com/jayway/awaitility>awaitility</a> test framework to check that the request can be served. It would fail the test if the server does not start.</span></td></tr></tbody></table></div></p><p>It’s now time to implement a real test. Let’s check we can retrieve an individual product:</p><pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>checkThatWeCanRetrieveIndividualProduct</span><span class=hljs-params>()</span> </span>{
  <span class=hljs-comment>// Get the list of bottles, ensure it's a success and extract the first id.</span>
  <span class=hljs-keyword>final</span> <span class=hljs-keyword>int</span> id = get(<span class=hljs-string>"/api/whiskies"</span>).then()
      .assertThat()
      .statusCode(<span class=hljs-number>200</span>)
      .extract()
      .jsonPath().getInt(<span class=hljs-string>"find { it.name=='Bowmore 15 Years Laimrig' }.id"</span>);
  <span class=hljs-comment>// Now get the individual resource and check the content</span>
  get(<span class=hljs-string>"/api/whiskies/"</span> + id).then()
      .assertThat()
      .statusCode(<span class=hljs-number>200</span>)
      .body(<span class=hljs-string>"name"</span>, equalTo(<span class=hljs-string>"Bowmore 15 Years Laimrig"</span>))
      .body(<span class=hljs-string>"origin"</span>, equalTo(<span class=hljs-string>"Scotland, Islay"</span>))
      .body(<span class=hljs-string>"id"</span>, equalTo(id));
}</code></pre><p>Here you can appreciate the power and expressiveness of Rest Assured. We retrieve the list of product, ensure the response is correct, and extract the _id_ of a specific bottle using a JSON (Groovy) Path expression.</p><p>Then, we try to retrieve the metadata of this individual product, and check the result.</p><p>Let’s now implement a more sophisticated scenario. Let’s add and delete a product:</p><pre><code class="hljs java"><span class=hljs-annotation>@Test</span>
<span class=hljs-function><span class=hljs-keyword>public</span> <span class=hljs-keyword>void</span> <span class=hljs-title>checkWeCanAddAndDeleteAProduct</span><span class=hljs-params>()</span> </span>{
  <span class=hljs-comment>// Create a new bottle and retrieve the result (as a Whisky instance).</span>
  Whisky whisky = given()
      .body(<span class=hljs-string>"{\"name\":\"Jameson\", \"origin\":\"Ireland\"}"</span>).request().post(<span class=hljs-string>"/api/whiskies"</span>).thenReturn().as(Whisky.class);
  assertThat(whisky.getName()).isEqualToIgnoringCase(<span class=hljs-string>"Jameson"</span>);
  assertThat(whisky.getOrigin()).isEqualToIgnoringCase(<span class=hljs-string>"Ireland"</span>);
  assertThat(whisky.getId()).isNotZero();
  <span class=hljs-comment>// Check that it has created an individual resource, and check the content.</span>
  get(<span class=hljs-string>"/api/whiskies/"</span> + whisky.getId()).then()
      .assertThat()
      .statusCode(<span class=hljs-number>200</span>)
      .body(<span class=hljs-string>"name"</span>, equalTo(<span class=hljs-string>"Jameson"</span>))
      .body(<span class=hljs-string>"origin"</span>, equalTo(<span class=hljs-string>"Ireland"</span>))
      .body(<span class=hljs-string>"id"</span>, equalTo(whisky.getId()));
  <span class=hljs-comment>// Delete the bottle</span>
  delete(<span class=hljs-string>"/api/whiskies/"</span> + whisky.getId()).then().assertThat().statusCode(<span class=hljs-number>204</span>);
  <span class=hljs-comment>// Check that the resource is not available anymore</span>
  get(<span class=hljs-string>"/api/whiskies/"</span> + whisky.getId()).then()
      .assertThat()
      .statusCode(<span class=hljs-number>404</span>);
}</code></pre>So, now we have integration tests let's try:<pre><code class="hljs bash">mvn clean verify</code></pre><p>Simple no? Well, simple once the setup is done right… You can continue implementing other integration tests to be sure that everything behave as you expect.</p><h2 id=dear-windows-users->Dear Windows users…</h2><p>This section is the bonus part for Windows user, or people wanting to run their integration tests on Windows machine too. The command we execute to stop the application is not going to work on Windows. Luckily, it’s possible to extend the <code>pom.xml</code> with a profile executed on Windows.</p><p>In your <code>pom.xml</code>, just after <code>&lt;/build&gt;</code>, add:</p><pre><code class="hljs xml"><span class=hljs-tag>&lt;<span class=hljs-title>profiles</span>&gt;</span>
  <span class=hljs-comment>&lt;!-- A profile for windows as the stop command is different --&gt;</span>
  <span class=hljs-tag>&lt;<span class=hljs-title>profile</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>windows<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>activation</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>os</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>family</span>&gt;</span>windows<span class=hljs-tag>&lt;/<span class=hljs-title>family</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>os</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>activation</span>&gt;</span>
    <span class=hljs-tag>&lt;<span class=hljs-title>build</span>&gt;</span>
      <span class=hljs-tag>&lt;<span class=hljs-title>plugins</span>&gt;</span>
        <span class=hljs-tag>&lt;<span class=hljs-title>plugin</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>artifactId</span>&gt;</span>maven-antrun-plugin<span class=hljs-tag>&lt;/<span class=hljs-title>artifactId</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>version</span>&gt;</span>1.8<span class=hljs-tag>&lt;/<span class=hljs-title>version</span>&gt;</span>
          <span class=hljs-tag>&lt;<span class=hljs-title>executions</span>&gt;</span>
            <span class=hljs-tag>&lt;<span class=hljs-title>execution</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>id</span>&gt;</span>stop-vertx-app<span class=hljs-tag>&lt;/<span class=hljs-title>id</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>phase</span>&gt;</span>post-integration-test<span class=hljs-tag>&lt;/<span class=hljs-title>phase</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>goals</span>&gt;</span>
                <span class=hljs-tag>&lt;<span class=hljs-title>goal</span>&gt;</span>run<span class=hljs-tag>&lt;/<span class=hljs-title>goal</span>&gt;</span>
              <span class=hljs-tag>&lt;/<span class=hljs-title>goals</span>&gt;</span>
              <span class=hljs-tag>&lt;<span class=hljs-title>configuration</span>&gt;</span>
                <span class=hljs-tag>&lt;<span class=hljs-title>target</span>&gt;</span>
                  <span class=hljs-tag>&lt;<span class=hljs-title>exec</span> <span class=hljs-attribute>executable</span>=<span class=hljs-value>"wmic"</span>
                      <span class=hljs-attribute>dir</span>=<span class=hljs-value>"${project.build.directory}"</span>
                      <span class=hljs-attribute>spawn</span>=<span class=hljs-value>"false"</span>&gt;</span>
                    <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"process"</span>/&gt;</span>
                    <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"where"</span>/&gt;</span>
                    <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"CommandLine like '%${project.artifactId}%' and not name='wmic.exe'"</span>/&gt;</span>
                    <span class=hljs-tag>&lt;<span class=hljs-title>arg</span> <span class=hljs-attribute>value</span>=<span class=hljs-value>"delete"</span>/&gt;</span>
                  <span class=hljs-tag>&lt;/<span class=hljs-title>exec</span>&gt;</span>
                <span class=hljs-tag>&lt;/<span class=hljs-title>target</span>&gt;</span>
              <span class=hljs-tag>&lt;/<span class=hljs-title>configuration</span>&gt;</span>
            <span class=hljs-tag>&lt;/<span class=hljs-title>execution</span>&gt;</span>
          <span class=hljs-tag>&lt;/<span class=hljs-title>executions</span>&gt;</span>
        <span class=hljs-tag>&lt;/<span class=hljs-title>plugin</span>&gt;</span>
      <span class=hljs-tag>&lt;/<span class=hljs-title>plugins</span>&gt;</span>
    <span class=hljs-tag>&lt;/<span class=hljs-title>build</span>&gt;</span>
  <span class=hljs-tag>&lt;/<span class=hljs-title>profile</span>&gt;</span>
<span class=hljs-tag>&lt;/<span class=hljs-title>profiles</span>&gt;</span></code></pre><p>This profile replaces the actions described above to stop the application with a version working on windows. The profile is automatically enabled on Windows. As on others operating systems, execute with:</p><pre><code class="hljs bash">mvn clean verify</code></pre><h2 id=conclusion>Conclusion</h2><p>Wow, what a trip ! We are done… In this post we have seen how we can gain confidence in Vert.x applications by implementing both unit and integration tests. Unit tests, thanks to vert.x unit, are able to check the asynchronous aspect of Vert.x application, but could be complex for large scenarios. Thanks to Rest Assured and AssertJ, integration tests are dead simple to write… but the setup is not straightforward. This post have shown how it can be configured easily. Obviously, you could also use AssertJ and Rest Assured in your unit tests.</p><p>In the <a href="http://vertx.io/blog/using-the-asynchronous-sql-client/">next post</a>, we replace the <em>in memory</em> backend with a database, and use asynchronous integration with this database.</p><p>Stay Tuned &amp; Happy Coding !</p></article></article></div><div class=row><div class=col-xs-12 id=disqus_thread></div></div><script>var disqus_config = function () {
  this.page.url = "https://vertx.tk/blog/unit-and-integration-tests/";
  this.page.identifier = "/blog/unit-and-integration-tests/";
  };
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://vertx.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><footer><div class=container><div class=row><div class="col-xs-4 col-sm-4 col-md-2 col-lg-2"><h2>Eclipse Vert.x</h2><ul class=list-unstyled><li><a href="https://vertx.tk/">主页</a></li><li><a href="https://vertx.tk/download/">下载</a></li><li><a href="https://vertx.tk/docs/">文档</a></li><li><a href=https://github.com/vert-x3/wiki/wiki>维基</a></li><li><a href="https://vertx.tk/blog/">博客</a></li></ul></div><div class="col-xs-4 col-sm-4 col-md-2 col-lg-2"><h2>Community</h2><ul class=list-unstyled><li><a href="https://vertx.tk/community/">Help &amp; Contributors</a></li><li><a href="https://vertx.tk/materials/">Learning materials</a></li><li><a href=https://groups.google.com/forum/?fromgroups#!forum/vertx>User Group</a></li><li><a href=https://groups.google.com/forum/?fromgroups#!forum/vertx-dev>Developer Group</a></li></ul></div><div class="col-xs-4 col-sm-4 col-md-2 col-lg-2"><h2>Eclipse</h2><ul class=list-unstyled><li><a href="http://www.eclipse.org/">Eclipse Foundation</a></li><li><a href=https://eclipse.org/legal/privacy.php>Privacy Policy</a></li><li><a href=https://eclipse.org/legal/termsofuse.php>Terms of Use</a></li><li><a href=https://eclipse.org/legal/copyright.php>Copyright Agent</a></li><li><a href=http://www.eclipse.org/legal>Legal Resources</a></li></ul></div><div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 copyright"><p>Eclipse Vert.x is open source and dual-licensed under the <a href=http://www.eclipse.org/legal/epl-v20.html>Eclipse Public License 2.0</a> and <a href=https://www.apache.org/licenses/LICENSE-2.0.html>Apache License 2.0</a>.</p><p>This website is licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0 License</a>.<br>Design by <a href=https://www.michel-kraemer.com>Michel Kr&auml;mer</a>.</p><div class=row><div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-2"><a href=http://eclipse.org><img class="logo eclipse-logo" src=https://vertx.tk/assets/eclipse_logo_grey_small.png width=204 height=48></a></div><div class="col-sm-12 col-md-5 col-md-offset-1 col-lg-offset-0"><a href=http://cloudbees.com><img class="logo cloudbees-logo" src=https://vertx.tk/assets/Button-Built-on-CB-1-grey.png width=180 height=48></a></div><div class="col-sm-12 col-md-5 col-md-offset-7 jprofiler"><a href=http://www.ej-technologies.com/products/jprofiler/overview.html style=text-decoration:none><img class="logo jprofiler-logo" src=https://vertx.tk/assets/jprofiler-logo.png width=48 height=48><span class=jprofiler-logo>&nbsp; JPROFILER</span></a></div></div></div></div></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js></script><script src=https://vertx.tk/javascripts/bootstrap.min.js></script><script src=https://vertx.tk/javascripts/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=stylesheet type=text/css href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css"><script src=//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js></script><script>window.addEventListener("load", function(){
window.cookieconsent.initialise({
  "palette": {
    "popup": {
      "background": "#64386b",
      "text": "#ffcdfd"
    },
    "button": {
      "background": "transparent",
      "text": "#f8a8ff",
      "border": "#f8a8ff"
    }
  },
  "content": {
    "message": "This website uses anonymous cookies to ensure we provide you the best experience. ",
    "link": "Opt out!",
    "href": "https://tools.google.com/dlpage/gaoptout/"
  }
})});</script></body></html>