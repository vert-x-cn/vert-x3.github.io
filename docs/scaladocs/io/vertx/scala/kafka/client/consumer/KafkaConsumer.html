<!DOCTYPE html >
<html>
        <head>
          <meta http-equiv="X-UA-Compatible" content="IE=edge" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
          <title>vertx-lang-scala-docs_2.12 3.6.0-SNAPSHOT API  - io.vertx.scala.kafka.client.consumer.KafkaConsumer</title>
          <meta name="description" content="vertx - lang - scala - docs 2.12 3.6.0 - SNAPSHOT API - io.vertx.scala.kafka.client.consumer.KafkaConsumer" />
          <meta name="keywords" content="vertx lang scala docs 2.12 3.6.0 SNAPSHOT API io.vertx.scala.kafka.client.consumer.KafkaConsumer" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../../../lib/index.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../../../../lib/jquery.panzoom.min.js"></script>
      <script type="text/javascript" src="../../../../../../lib/jquery.mousewheel.min.js"></script>
      <script type="text/javascript" src="../../../../../../lib/index.js"></script>
      <script type="text/javascript" src="../../../../../../index.js"></script>
      <script type="text/javascript" src="../../../../../../lib/scheduler.js"></script>
      <script type="text/javascript" src="../../../../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
        /* this variable can be used by the JS to determine the path to the root document */
        var toRoot = '../../../../../../';
      </script>
    
        </head>
        <body>
      <div id="search">
        <span id="doc-title">vertx-lang-scala-docs_2.12 3.6.0-SNAPSHOT API<span id="doc-version"></span></span>
        <span class="close-results"><span class="left">&lt;</span> Back</span>
        <div id="textfilter">
          <span class="input">
            <input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/" />
            <i class="clear material-icons"></i>
            <i id="search-icon" class="material-icons"></i>
          </span>
        </div>
    </div>
      <div id="search-results">
        <div id="search-progress">
          <div id="progress-fill"></div>
        </div>
        <div id="results-content">
          <div id="entity-results"></div>
          <div id="member-results"></div>
        </div>
      </div>
      <div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;">
        <div id="content-container" style="-webkit-overflow-scrolling: touch;">
          <div id="subpackage-spacer">
            <div id="packages">
              <h1>Packages</h1>
              <ul>
                <li name="_root_.root" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="_root_"></a><a id="root:_root_"></a>
      <span class="permalink">
      <a href="index.html#_root_" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../../../index.html"><span class="name">root</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="_root_.io" visbl="pub" class="indented1 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="io"></a><a id="io:io"></a>
      <span class="permalink">
      <a href="index.html#io" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../../index.html"><span class="name">io</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../../index.html" class="extype" name="_root_">root</a></dd></dl></div>
    </li><li name="io.vertx" visbl="pub" class="indented2 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="vertx"></a><a id="vertx:vertx"></a>
      <span class="permalink">
      <a href="../io/index.html#vertx" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../../index.html"><span class="name">vertx</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../../index.html" class="extype" name="io">io</a></dd></dl></div>
    </li><li name="io.vertx.scala" visbl="pub" class="indented3 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="scala"></a><a id="scala:scala"></a>
      <span class="permalink">
      <a href="../../io/vertx/index.html#scala" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../../index.html"><span class="name">scala</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../../index.html" class="extype" name="io.vertx">vertx</a></dd></dl></div>
    </li><li name="io.vertx.scala.kafka" visbl="pub" class="indented4 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="kafka"></a><a id="kafka:kafka"></a>
      <span class="permalink">
      <a href="../../../io/vertx/scala/index.html#kafka" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../../index.html"><span class="name">kafka</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../../index.html" class="extype" name="io.vertx.scala">scala</a></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client" visbl="pub" class="indented5 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="client"></a><a id="client:client"></a>
      <span class="permalink">
      <a href="../../../../io/vertx/scala/kafka/index.html#client" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="../index.html"><span class="name">client</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../index.html" class="extype" name="io.vertx.scala.kafka">kafka</a></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer" visbl="pub" class="indented6 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="consumer"></a><a id="consumer:consumer"></a>
      <span class="permalink">
      <a href="../../../../../io/vertx/scala/kafka/client/index.html#consumer" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <a title="" href="index.html"><span class="name">consumer</span></a>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../index.html" class="extype" name="io.vertx.scala.kafka.client">client</a></dd></dl></div>
    </li><li class="current-entities indented6">
                        <a class="object" href="KafkaConsumer$.html" title=""></a>
                        <a class="class" href="" title="Vert.x Kafka consumer."></a>
                        <a href="" title="Vert.x Kafka consumer.">KafkaConsumer</a>
                      </li><li class="current-entities indented6">
                        <a class="object" href="KafkaConsumerRecord$.html" title=""></a>
                        <a class="class" href="KafkaConsumerRecord.html" title="Vert.x Kafka consumer record"></a>
                        <a href="KafkaConsumerRecord.html" title="Vert.x Kafka consumer record">KafkaConsumerRecord</a>
                      </li><li class="current-entities indented6">
                        <a class="object" href="KafkaConsumerRecords$.html" title=""></a>
                        <a class="class" href="KafkaConsumerRecords.html" title="Vert.x Kafka consumer records"></a>
                        <a href="KafkaConsumerRecords.html" title="Vert.x Kafka consumer records">KafkaConsumerRecords</a>
                      </li><li class="current-entities indented6">
                        <a class="object" href="OffsetAndMetadata$.html" title=""></a>
                        <a class="class" href="OffsetAndMetadata.html" title="Provide additional metadata when an offset is committed"></a>
                        <a href="OffsetAndMetadata.html" title="Provide additional metadata when an offset is committed">OffsetAndMetadata</a>
                      </li><li class="current-entities indented6">
                        <a class="object" href="OffsetAndTimestamp$.html" title=""></a>
                        <a class="class" href="OffsetAndTimestamp.html" title="Represent information related to a Offset with timestamp information"></a>
                        <a href="OffsetAndTimestamp.html" title="Represent information related to a Offset with timestamp information">OffsetAndTimestamp</a>
                      </li>
              </ul>
            </div>
          </div>
          <div id="content">
            <body class="class type">
      <div id="definition">
        <a href="KafkaConsumer$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a>
        <p id="owner"><a href="../../../../../index.html" class="extype" name="io">io</a>.<a href="../../../../index.html" class="extype" name="io.vertx">vertx</a>.<a href="../../../index.html" class="extype" name="io.vertx.scala">scala</a>.<a href="../../index.html" class="extype" name="io.vertx.scala.kafka">kafka</a>.<a href="../index.html" class="extype" name="io.vertx.scala.kafka.client">client</a>.<a href="index.html" class="extype" name="io.vertx.scala.kafka.client.consumer">consumer</a></p>
        <h1><a href="KafkaConsumer$.html" title="See companion object">KafkaConsumer</a><span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span></h1>
        <h3><span class="morelinks"><div>
            Companion <a href="KafkaConsumer$.html" title="See companion object">object KafkaConsumer</a>
          </div></span></h3>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">KafkaConsumer</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="result"> extends <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a>[<a href="KafkaConsumerRecord.html" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord">KafkaConsumerRecord</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]]</span>
      </span>
      </h4>

      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Vert.x Kafka consumer.</p><p>You receive Kafka records by providing a <a href="#handler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#handler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#handler</a>. As messages arrive the handler
will be called with the records.</p><p>The <a href="#pause(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause">io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause</a> and <a href="#resume(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume">io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume</a> provides global control over reading the records from the consumer.</p><p>The <a href="#pause(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause">io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause</a> and <a href="#resume(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume">io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume</a> provides finer grained control over reading records
for specific Topic/Partition, these are Kafka's specific operations.</p></div><div class="toggleContainer block">
          <span class="toggle">
            Linear Supertypes
          </span>
          <div class="superTypes hiddenContent"><a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a>[<a href="KafkaConsumerRecord.html" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord">KafkaConsumerRecord</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]], <a href="../../../core/streams/StreamBase.html" class="extype" name="io.vertx.scala.core.streams.StreamBase">StreamBase</a>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div class="toggle"></div>
        <div id="memberfilter">
          <i class="material-icons arrow"></i>
          <span class="input">
            <input id="mbrsel-input" placeholder="Filter all members" type="text" accesskey="/" />
          </span>
          <i class="clear material-icons"></i>
        </div>
        <div id="filterby">
          <div id="order">
            <span class="filtertype">Ordering</span>
            <ol>
              
              <li class="alpha in"><span>Alphabetic</span></li>
              <li class="inherit out"><span>By Inheritance</span></li>
            </ol>
          </div>
          <div class="ancestors">
                  <span class="filtertype">Inherited<br />
                  </span>
                  <ol id="linearization">
                    <li class="in" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer"><span>KafkaConsumer</span></li><li class="in" name="io.vertx.scala.core.streams.ReadStream"><span>ReadStream</span></li><li class="in" name="io.vertx.scala.core.streams.StreamBase"><span>StreamBase</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                  </ol>
                </div><div class="ancestors">
              <span class="filtertype"></span>
              <ol>
                <li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show All</span></li>
              </ol>
            </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#&lt;init&gt;" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="&lt;init&gt;(_asJava:Object)(implicitevidence$1:reflect.runtime.universe.TypeTag[K],implicitevidence$2:reflect.runtime.universe.TypeTag[V]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="&lt;init&gt;:KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#&lt;init&gt;(_asJava:Object)(implicitevidence$1:reflect.runtime.universe.TypeTag[K],implicitevidence$2:reflect.runtime.universe.TypeTag[V]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">KafkaConsumer</span><span class="params">(<span name="_asJava">_asJava: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <span class="extype" name="scala.reflect.api.TypeTags.TypeTag">scala.reflect.api.JavaUniverse.TypeTag</span>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>]</span>, <span name="arg1">arg1: <span class="extype" name="scala.reflect.api.TypeTags.TypeTag">scala.reflect.api.JavaUniverse.TypeTag</span>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>)</span>
      </span>
      
      
    </li></ol>
            </div>

        

        

        <div class="values members">
              <h3>Value Members</h3>
              <ol>
                <li name="scala.AnyRef#!=" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a><a id="!=(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#!=(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html###():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a><a id="==(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#==(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#asInstanceOf[T0]:T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#asJava" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asJava:Object"></a><a id="asJava:AnyRef"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#asJava:Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asJava</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a> → <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a> → <a href="../../../core/streams/StreamBase.html" class="extype" name="io.vertx.scala.core.streams.StreamBase">StreamBase</a></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assign" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="assign(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="assign(Set[TopicPartition],Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assign(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">assign</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Manually assign a list of partition to this consumer.</p><div class="fullcomment"><div class="comment cmt"><p>Manually assign a list of partition to this consumer.</p><p>Due to internal buffering of messages, when reassigning
the old set of partitions may remain in effect
(as observed by the  record handler)<code>
until some time <em>after</em> the given </code>completionHandler<code>
is called. In contrast, the once the given </code>completionHandler<code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new set of partitions.   * @param topicPartitions partitions which want assigned</code></p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assign" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="assign(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="assign(TopicPartition,Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assign(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">assign</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Manually assign a partition to this consumer.</p><div class="fullcomment"><div class="comment cmt"><p>Manually assign a partition to this consumer.</p><p>Due to internal buffering of messages, when reassigning
the old partition may remain in effect
(as observed by the  record handler)<code>
until some time <em>after</em> the given </code>completionHandler<code>
is called. In contrast, the once the given </code>completionHandler<code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new partition.   * @param topicPartition partition which want assigned see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></code></p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assign" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="assign(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="assign(Set[TopicPartition]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assign(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">assign</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Manually assign a list of partition to this consumer.</p><div class="fullcomment"><div class="comment cmt"><p>Manually assign a list of partition to this consumer.   * @param topicPartitions partitions which want assigned</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assign" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="assign(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="assign(TopicPartition):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assign(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">assign</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Manually assign a partition to this consumer.</p><div class="fullcomment"><div class="comment cmt"><p>Manually assign a partition to this consumer.   * @param topicPartition partition which want assigned see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assignFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="assignFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]"></a><a id="assignFuture(Set[TopicPartition]):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assignFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">assignFuture</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#assign(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assign">assign</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assignFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="assignFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]"></a><a id="assignFuture(TopicPartition):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assignFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">assignFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#assign(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assign">assign</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assignment" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="assignment(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="assignment(Handler[AsyncResult[Set[TopicPartition]]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assignment(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">assignment</span><span class="params">(<span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Get the set of partitions currently assigned to this consumer.</p><div class="fullcomment"><div class="comment cmt"><p>Get the set of partitions currently assigned to this consumer.   * @param handler handler called on operation completed</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assignmentFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="assignmentFuture():scala.concurrent.Future[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]"></a><a id="assignmentFuture():Future[Set[TopicPartition]]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#assignmentFuture():scala.concurrent.Future[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">assignmentFuture</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#assignment(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#assignment">assignment</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="batchHandler(Handler[KafkaConsumerRecords[K,V]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">batchHandler</span><span class="params">(<span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<a href="KafkaConsumerRecords.html" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords">KafkaConsumerRecords</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Set the handler to be used when batches of messages are fetched
from the Kafka server.</p><div class="fullcomment"><div class="comment cmt"><p>Set the handler to be used when batches of messages are fetched
from the Kafka server. Batch handlers need to take care not to block
the event loop when dealing with large batches. It is better to process
records individually using the <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">io.vertx.scala.kafka.client.consumer.KafkaConsumer</a>.   * @param handler handler called when batches of messages are fetched</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#beginningOffsets" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="beginningOffsets(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit"></a><a id="beginningOffsets(TopicPartition,Handler[AsyncResult[Long]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#beginningOffsets(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">beginningOffsets</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Long">Long</span>]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Get the first offset for the given partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Get the first offset for the given partitions.   * @param topicPartition the partition to get the earliest offset. see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">handler</dt><dd class="cmt"><p>handler called on operation completed. Returns the earliest available offset for the given partition</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#beginningOffsetsFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="beginningOffsetsFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Long]"></a><a id="beginningOffsetsFuture(TopicPartition):Future[Long]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#beginningOffsetsFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">beginningOffsetsFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#beginningOffsets(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#beginningOffsets">beginningOffsets</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="scala.AnyRef#clone" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a><a id="clone():AnyRef"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#clone():Object" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#close" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="close(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):Unit"></a><a id="close(Handler[AsyncResult[Unit]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#close(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">close</span><span class="params">(<span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Close the consumer   * @param completionHandler handler called on operation completed
</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#close" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="close():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#close():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">close</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Close the consumer
</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#closeFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="closeFuture():scala.concurrent.Future[Unit]"></a><a id="closeFuture():Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#closeFuture():scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">closeFuture</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#close(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#close">close</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#commit" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="commit(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):Unit"></a><a id="commit(Handler[AsyncResult[Unit]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#commit(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commit</span><span class="params">(<span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Commit current offsets for all the subscribed list of topics and partition.</p><div class="fullcomment"><div class="comment cmt"><p>Commit current offsets for all the subscribed list of topics and partition.   * @param completionHandler handler called on operation completed
</p></div></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#commit" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="commit():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#commit():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commit</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Commit current offsets for all the subscribed list of topics and partition.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#commitFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="commitFuture():scala.concurrent.Future[Unit]"></a><a id="commitFuture():Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#commitFuture():scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commitFuture</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#commit(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#commit">commit</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#committed" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="committed(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.OffsetAndMetadata]]):Unit"></a><a id="committed(TopicPartition,Handler[AsyncResult[OffsetAndMetadata]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#committed(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.OffsetAndMetadata]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">committed</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<a href="OffsetAndMetadata.html" class="extype" name="io.vertx.scala.kafka.client.consumer.OffsetAndMetadata">OffsetAndMetadata</a>]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Get the last committed offset for the given partition (whether the commit happened by this process or another).</p><div class="fullcomment"><div class="comment cmt"><p>Get the last committed offset for the given partition (whether the commit happened by this process or another).   * @param topicPartition topic partition for getting last committed offset see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">handler</dt><dd class="cmt"><p>handler called on operation completed</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#committedFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="committedFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[io.vertx.scala.kafka.client.consumer.OffsetAndMetadata]"></a><a id="committedFuture(TopicPartition):Future[OffsetAndMetadata]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#committedFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[io.vertx.scala.kafka.client.consumer.OffsetAndMetadata]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">committedFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="OffsetAndMetadata.html" class="extype" name="io.vertx.scala.kafka.client.consumer.OffsetAndMetadata">OffsetAndMetadata</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#committed(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.OffsetAndMetadata]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#committed">committed</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#endHandler" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="endHandler(endHandler:io.vertx.core.Handler[Unit]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="endHandler(Handler[Unit]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#endHandler(endHandler:io.vertx.core.Handler[Unit]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">endHandler</span><span class="params">(<span name="endHandler">endHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Set an end handler.</p><div class="fullcomment"><div class="comment cmt"><p>Set an end handler. Once the stream has ended, and there is no more data to be read, this handler will be called.   * @return a reference to this, so the API can be used fluently
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a> → <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#endOffsets" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="endOffsets(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit"></a><a id="endOffsets(TopicPartition,Handler[AsyncResult[Long]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#endOffsets(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">endOffsets</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Long">Long</span>]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Get the last offset for the given partition.</p><div class="fullcomment"><div class="comment cmt"><p>Get the last offset for the given partition. The last offset of a partition is the offset
of the upcoming message, i.e. the offset of the last available message + 1.   * @param topicPartition the partition to get the end offset. see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">handler</dt><dd class="cmt"><p>handler called on operation completed. The end offset for the given partition.</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#endOffsetsFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="endOffsetsFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Long]"></a><a id="endOffsetsFuture(TopicPartition):Future[Long]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#endOffsetsFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">endOffsetsFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#endOffsets(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#endOffsets">endOffsets</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="scala.AnyRef#eq" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a><a id="eq(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#eq(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a><a id="equals(Any):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#equals(x$1:Any):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#exceptionHandler" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="exceptionHandler(handler:io.vertx.core.Handler[Throwable]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="exceptionHandler(Handler[Throwable]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#exceptionHandler(handler:io.vertx.core.Handler[Throwable]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">exceptionHandler</span><span class="params">(<span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="scala.Throwable">Throwable</span>]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Set an exception handler on the read stream.</p><div class="fullcomment"><div class="comment cmt"><p>Set an exception handler on the read stream.   * @param handler the exception handler</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a reference to this, so the API can be used fluently</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a> → <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a> → <a href="../../../core/streams/StreamBase.html" class="extype" name="io.vertx.scala.core.streams.StreamBase">StreamBase</a></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#fetch" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fetch(arg0:Long):io.vertx.scala.core.streams.ReadStream[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord[K,V]]"></a><a id="fetch(Long):ReadStream[KafkaConsumerRecord[K,V]]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#fetch(arg0:Long):io.vertx.scala.core.streams.ReadStream[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord[K,V]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fetch</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a>[<a href="KafkaConsumerRecord.html" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord">KafkaConsumerRecord</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Fetch the specified <code>amount</code> of elements.</p><div class="fullcomment"><div class="comment cmt"><p>Fetch the specified <code>amount</code> of elements. If the <code>ReadStream</code> has been paused, reading will
recommence with the specified <code>amount</code> of items, otherwise the specified <code>amount</code> will
be added to the current stream demand.   * @return a reference to this, so the API can be used fluently
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a> → <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#finalize():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../../../java/lang/index.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#getClass():Class[_]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#handler" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="handler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="handler(Handler[KafkaConsumerRecord[K,V]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#handler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handler</span><span class="params">(<span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<a href="KafkaConsumerRecord.html" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord">KafkaConsumerRecord</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Set a data handler.</p><div class="fullcomment"><div class="comment cmt"><p>Set a data handler. As data is read, the handler will be called with the data.   * @return a reference to this, so the API can be used fluently
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a> → <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a></dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#hashCode():Int" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#isInstanceOf[T0]:Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a><a id="ne(AnyRef):Boolean"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#ne(x$1:AnyRef):Boolean" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#notify():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#notifyAll():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#offsetsForTimes" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="offsetsForTimes(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,timestamp:Long,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.OffsetAndTimestamp]]):Unit"></a><a id="offsetsForTimes(TopicPartition,Long,Handler[AsyncResult[OffsetAndTimestamp]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#offsetsForTimes(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,timestamp:Long,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.OffsetAndTimestamp]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">offsetsForTimes</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="timestamp">timestamp: <span class="extype" name="scala.Long">Long</span></span>, <span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<a href="OffsetAndTimestamp.html" class="extype" name="io.vertx.scala.kafka.client.consumer.OffsetAndTimestamp">OffsetAndTimestamp</a>]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Look up the offset for the given partition by timestamp.</p><div class="fullcomment"><div class="comment cmt"><p>Look up the offset for the given partition by timestamp. Note: the result might be null in case
for the given timestamp no offset can be found -- e.g., when the timestamp refers to the future   * @param topicPartition TopicPartition to query. see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">timestamp</dt><dd class="cmt"><p>Timestamp to be used in the query.</p></dd><dt class="param">handler</dt><dd class="cmt"><p>handler called on operation completed</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#offsetsForTimesFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="offsetsForTimesFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,timestamp:Long):scala.concurrent.Future[io.vertx.scala.kafka.client.consumer.OffsetAndTimestamp]"></a><a id="offsetsForTimesFuture(TopicPartition,Long):Future[OffsetAndTimestamp]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#offsetsForTimesFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,timestamp:Long):scala.concurrent.Future[io.vertx.scala.kafka.client.consumer.OffsetAndTimestamp]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">offsetsForTimesFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="timestamp">timestamp: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="OffsetAndTimestamp.html" class="extype" name="io.vertx.scala.kafka.client.consumer.OffsetAndTimestamp">OffsetAndTimestamp</a>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#offsetsForTimes(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,timestamp:Long,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.OffsetAndTimestamp]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#offsetsForTimes">offsetsForTimes</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#partitionsAssignedHandler" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="partitionsAssignedHandler(handler:io.vertx.core.Handler[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="partitionsAssignedHandler(Handler[Set[TopicPartition]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsAssignedHandler(handler:io.vertx.core.Handler[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">partitionsAssignedHandler</span><span class="params">(<span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Set the handler called when topic partitions are assigned to the consumer   * @param handler handler called on assigned topic partitions</p><div class="fullcomment"><div class="comment cmt"><p>Set the handler called when topic partitions are assigned to the consumer   * @param handler handler called on assigned topic partitions</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#partitionsFor" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="partitionsFor(topic:String,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Buffer[io.vertx.scala.kafka.client.common.PartitionInfo]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="partitionsFor(String,Handler[AsyncResult[Buffer[PartitionInfo]]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsFor(topic:String,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Buffer[io.vertx.scala.kafka.client.common.PartitionInfo]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">partitionsFor</span><span class="params">(<span name="topic">topic: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.collection.mutable.Buffer">Buffer</span>[<a href="../common/PartitionInfo.html" class="extype" name="io.vertx.scala.kafka.client.common.PartitionInfo">PartitionInfo</a>]]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Get metadata about the partitions for a given topic.</p><div class="fullcomment"><div class="comment cmt"><p>Get metadata about the partitions for a given topic.   * @param topic topic partition for which getting partitions info</p></div><dl class="paramcmts block"><dt class="param">handler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#partitionsForFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="partitionsForFuture(topic:String):scala.concurrent.Future[scala.collection.mutable.Buffer[io.vertx.scala.kafka.client.common.PartitionInfo]]"></a><a id="partitionsForFuture(String):Future[Buffer[PartitionInfo]]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsForFuture(topic:String):scala.concurrent.Future[scala.collection.mutable.Buffer[io.vertx.scala.kafka.client.common.PartitionInfo]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">partitionsForFuture</span><span class="params">(<span name="topic">topic: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.collection.mutable.Buffer">Buffer</span>[<a href="../common/PartitionInfo.html" class="extype" name="io.vertx.scala.kafka.client.common.PartitionInfo">PartitionInfo</a>]]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#partitionsFor(topic:String,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Buffer[io.vertx.scala.kafka.client.common.PartitionInfo]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#partitionsFor">partitionsFor</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#partitionsRevokedHandler" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="partitionsRevokedHandler(handler:io.vertx.core.Handler[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="partitionsRevokedHandler(Handler[Set[TopicPartition]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#partitionsRevokedHandler(handler:io.vertx.core.Handler[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">partitionsRevokedHandler</span><span class="params">(<span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Set the handler called when topic partitions are revoked to the consumer   * @param handler handler called on revoked topic partitions</p><div class="fullcomment"><div class="comment cmt"><p>Set the handler called when topic partitions are revoked to the consumer   * @param handler handler called on revoked topic partitions</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pause(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="pause(Set[TopicPartition],Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pause(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pause</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Suspend fetching from the requested partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Suspend fetching from the requested partitions.</p><p>Due to internal buffering of messages,
the  will
continue to observe messages from the given <code>topicPartitions</code>
until some time <em>after</em> the given <code>completionHandler</code>
is called. In contrast, the once the given <code>completionHandler</code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will not see messages
from the given <code>topicPartitions</code>.   * @param topicPartitions topic partition from which suspend fetching</p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pause(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="pause(TopicPartition,Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pause(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pause</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Suspend fetching from the requested partition.</p><div class="fullcomment"><div class="comment cmt"><p>Suspend fetching from the requested partition.</p><p>Due to internal buffering of messages,
the  will
continue to observe messages from the given <code>topicPartition</code>
until some time <em>after</em> the given <code>completionHandler</code>
is called. In contrast, the once the given <code>completionHandler</code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will not see messages
from the given <code>topicPartition</code>.   * @param topicPartition topic partition from which suspend fetching see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pause(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="pause(Set[TopicPartition]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pause(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pause</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Suspend fetching from the requested partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Suspend fetching from the requested partitions.   * @param topicPartitions topic partition from which suspend fetching</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pause(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="pause(TopicPartition):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pause(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pause</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Suspend fetching from the requested partition.</p><div class="fullcomment"><div class="comment cmt"><p>Suspend fetching from the requested partition.   * @param topicPartition topic partition from which suspend fetching see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pause():io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="pause():KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pause():io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pause</span><span class="params">()</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Pause the <code>ReadStream</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Pause the <code>ReadStream</code>. While it's paused, no data will be sent to the data <code>handler</code>   * @return a reference to this, so the API can be used fluently
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a> → <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pauseFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="pauseFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]"></a><a id="pauseFuture(Set[TopicPartition]):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pauseFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pauseFuture</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#pause(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause">pause</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pauseFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="pauseFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]"></a><a id="pauseFuture(TopicPartition):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pauseFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pauseFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#pause(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pause">pause</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#paused" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="paused(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]]):Unit"></a><a id="paused(Handler[AsyncResult[Set[TopicPartition]]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#paused(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">paused</span><span class="params">(<span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Get the set of partitions that were previously paused by a call to pause(Set).</p><div class="fullcomment"><div class="comment cmt"><p>Get the set of partitions that were previously paused by a call to pause(Set).   * @param handler handler called on operation completed
</p></div></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pausedFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="pausedFuture():scala.concurrent.Future[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]"></a><a id="pausedFuture():Future[Set[TopicPartition]]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pausedFuture():scala.concurrent.Future[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pausedFuture</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#paused(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#paused">paused</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#poll" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="poll(timeout:Long,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]]):Unit"></a><a id="poll(Long,Handler[AsyncResult[KafkaConsumerRecords[K,V]]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#poll(timeout:Long,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">poll</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.Long">Long</span></span>, <span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<a href="KafkaConsumerRecords.html" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords">KafkaConsumerRecords</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Executes a poll for getting messages from Kafka   * @param timeout The time, in milliseconds, spent waiting in poll if data is not available in the buffer.</p><div class="fullcomment"><div class="comment cmt"><p>Executes a poll for getting messages from Kafka   * @param timeout The time, in milliseconds, spent waiting in poll if data is not available in the buffer. If 0, returns immediately with any records that are available currently in the native Kafka consumer's buffer, else returns empty. Must not be negative.</p></div><dl class="paramcmts block"><dt class="param">handler</dt><dd class="cmt"><p>handler called after the poll with batch of records (can be empty).</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pollFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="pollFuture(timeout:Long):scala.concurrent.Future[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]"></a><a id="pollFuture(Long):Future[KafkaConsumerRecords[K,V]]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pollFuture(timeout:Long):scala.concurrent.Future[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pollFuture</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<a href="KafkaConsumerRecords.html" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords">KafkaConsumerRecords</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#poll(timeout:Long,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#poll">poll</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#pollTimeout" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pollTimeout(timeout:Long):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="pollTimeout(Long):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#pollTimeout(timeout:Long):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">pollTimeout</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Sets the poll timeout (in ms) for the underlying native Kafka Consumer.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the poll timeout (in ms) for the underlying native Kafka Consumer. Defaults to 1000.
Setting timeout to a lower value results in a more 'responsive' client, because it will block for a shorter period
if no data is available in the assigned partition and therefore allows subsequent actions to be executed with a shorter
delay. At the same time, the client will poll more frequently and thus will potentially create a higher load on the Kafka Broker.   * @param timeout The time, in milliseconds, spent waiting in poll if data is not available in the buffer. If 0, returns immediately with any records that are available currently in the native Kafka consumer's buffer, else returns empty. Must not be negative.
</p></div></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#position" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="position(partition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit"></a><a id="position(TopicPartition,Handler[AsyncResult[Long]]):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#position(partition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">position</span><span class="params">(<span name="partition">partition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Long">Long</span>]]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <p class="shortcomment cmt">Get the offset of the next record that will be fetched (if a record with that offset exists).</p><div class="fullcomment"><div class="comment cmt"><p>Get the offset of the next record that will be fetched (if a record with that offset exists).   * @param partition The partition to get the position for see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">handler</dt><dd class="cmt"><p>handler called on operation completed</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#positionFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="positionFuture(partition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Long]"></a><a id="positionFuture(TopicPartition):Future[Long]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#positionFuture(partition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Long]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">positionFuture</span><span class="params">(<span name="partition">partition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Long">Long</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#position(partition:io.vertx.scala.kafka.client.common.TopicPartition,handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Long]]):Unit" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#position">position</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="resume(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="resume(Set[TopicPartition],Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resume(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resume</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Resume specified partitions which have been paused with pause.</p><div class="fullcomment"><div class="comment cmt"><p>Resume specified partitions which have been paused with pause.   * @param topicPartitions topic partition from which resume fetching</p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="resume(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="resume(TopicPartition,Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resume(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resume</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Resume specified partition which have been paused with pause.</p><div class="fullcomment"><div class="comment cmt"><p>Resume specified partition which have been paused with pause.   * @param topicPartition topic partition from which resume fetching see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="resume(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="resume(Set[TopicPartition]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resume(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resume</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Resume specified partitions which have been paused with pause.</p><div class="fullcomment"><div class="comment cmt"><p>Resume specified partitions which have been paused with pause.   * @param topicPartitions topic partition from which resume fetching</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="resume(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="resume(TopicPartition):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resume(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resume</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Resume specified partition which have been paused with pause.</p><div class="fullcomment"><div class="comment cmt"><p>Resume specified partition which have been paused with pause.   * @param topicPartition topic partition from which resume fetching see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="resume():io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="resume():KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resume():io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resume</span><span class="params">()</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Resume reading.</p><div class="fullcomment"><div class="comment cmt"><p>Resume reading. If the <code>ReadStream</code> has been paused, reading will recommence on it.   * @return a reference to this, so the API can be used fluently
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a> → <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resumeFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="resumeFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]"></a><a id="resumeFuture(Set[TopicPartition]):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resumeFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resumeFuture</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#resume(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume">resume</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resumeFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="resumeFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]"></a><a id="resumeFuture(TopicPartition):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#resumeFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">resumeFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#resume(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#resume">resume</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seek" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seek(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,offset:Long,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seek(TopicPartition,Long,Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seek(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,offset:Long,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seek</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Overrides the fetch offsets that the consumer will use on the next poll.</p><div class="fullcomment"><div class="comment cmt"><p>Overrides the fetch offsets that the consumer will use on the next poll.</p><p>Due to internal buffering of messages,
the  will
continue to observe messages fetched with respect to the old offset
until some time <em>after</em> the given <code>completionHandler</code>
is called. In contrast, the once the given <code>completionHandler</code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new offset.   * @param topicPartition topic partition for which seek see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">offset</dt><dd class="cmt"><p>offset to seek inside the topic partition</p></dd><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seek" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seek(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,offset:Long):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seek(TopicPartition,Long):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seek(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,offset:Long):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seek</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Overrides the fetch offsets that the consumer will use on the next poll.</p><div class="fullcomment"><div class="comment cmt"><p>Overrides the fetch offsets that the consumer will use on the next poll.   * @param topicPartition topic partition for which seek see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">offset</dt><dd class="cmt"><p>offset to seek inside the topic partition</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="seekFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,offset:Long):scala.concurrent.Future[Unit]"></a><a id="seekFuture(TopicPartition,Long):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,offset:Long):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="offset">offset: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#seek(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,offset:Long,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seek">seek</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToBeginning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seekToBeginning(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seekToBeginning(Set[TopicPartition],Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginning(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToBeginning</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Seek to the first offset for each of the given partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Seek to the first offset for each of the given partitions.</p><p>Due to internal buffering of messages,
the  will
continue to observe messages fetched with respect to the old offset
until some time <em>after</em> the given <code>completionHandler</code>
is called. In contrast, the once the given <code>completionHandler</code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new offset.   * @param topicPartitions topic partition for which seek</p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToBeginning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seekToBeginning(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seekToBeginning(TopicPartition,Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginning(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToBeginning</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Seek to the first offset for each of the given partition.</p><div class="fullcomment"><div class="comment cmt"><p>Seek to the first offset for each of the given partition.</p><p>Due to internal buffering of messages,
the  will
continue to observe messages fetched with respect to the old offset
until some time <em>after</em> the given <code>completionHandler</code>
is called. In contrast, the once the given <code>completionHandler</code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new offset.   * @param topicPartition topic partition for which seek see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToBeginning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seekToBeginning(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seekToBeginning(Set[TopicPartition]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginning(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToBeginning</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Seek to the first offset for each of the given partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Seek to the first offset for each of the given partitions.   * @param topicPartitions topic partition for which seek</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToBeginning" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seekToBeginning(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seekToBeginning(TopicPartition):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginning(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToBeginning</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Seek to the first offset for each of the given partition.</p><div class="fullcomment"><div class="comment cmt"><p>Seek to the first offset for each of the given partition.   * @param topicPartition topic partition for which seek see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToBeginningFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="seekToBeginningFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]"></a><a id="seekToBeginningFuture(Set[TopicPartition]):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginningFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToBeginningFuture</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#seekToBeginning(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToBeginning">seekToBeginning</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToBeginningFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="seekToBeginningFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]"></a><a id="seekToBeginningFuture(TopicPartition):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToBeginningFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToBeginningFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#seekToBeginning(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToBeginning">seekToBeginning</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToEnd" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seekToEnd(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seekToEnd(Set[TopicPartition],Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEnd(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToEnd</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Seek to the last offset for each of the given partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Seek to the last offset for each of the given partitions.</p><p>Due to internal buffering of messages,
the  will
continue to observe messages fetched with respect to the old offset
until some time <em>after</em> the given <code>completionHandler</code>
is called. In contrast, the once the given <code>completionHandler</code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new offset.   * @param topicPartitions topic partition for which seek</p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToEnd" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seekToEnd(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seekToEnd(TopicPartition,Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEnd(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToEnd</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Seek to the last offset for each of the given partition.</p><div class="fullcomment"><div class="comment cmt"><p>Seek to the last offset for each of the given partition.</p><p>Due to internal buffering of messages,
the  will
continue to observe messages fetched with respect to the old offset
until some time <em>after</em> the given <code>completionHandler</code>
is called. In contrast, the once the given <code>completionHandler</code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new offset.   * @param topicPartition topic partition for which seek see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToEnd" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seekToEnd(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seekToEnd(Set[TopicPartition]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEnd(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToEnd</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Seek to the last offset for each of the given partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Seek to the last offset for each of the given partitions.   * @param topicPartitions topic partition for which seek</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToEnd" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="seekToEnd(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="seekToEnd(TopicPartition):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEnd(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToEnd</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Seek to the last offset for each of the given partition.</p><div class="fullcomment"><div class="comment cmt"><p>Seek to the last offset for each of the given partition.   * @param topicPartition topic partition for which seek see <a href="../../../../../../../../cheatsheet/TopicPartition.html">TopicPartition</a></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToEndFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="seekToEndFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]"></a><a id="seekToEndFuture(Set[TopicPartition]):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEndFuture(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition]):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToEndFuture</span><span class="params">(<span name="topicPartitions">topicPartitions: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#seekToEnd(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToEnd">seekToEnd</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToEndFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="seekToEndFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]"></a><a id="seekToEndFuture(TopicPartition):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#seekToEndFuture(topicPartition:io.vertx.scala.kafka.client.common.TopicPartition):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">seekToEndFuture</span><span class="params">(<span name="topicPartition">topicPartition: <a href="../common/TopicPartition.html" class="extype" name="io.vertx.scala.kafka.client.common.TopicPartition">TopicPartition</a></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#seekToEnd(topicPartitions:scala.collection.mutable.Set[io.vertx.scala.kafka.client.common.TopicPartition],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#seekToEnd">seekToEnd</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscribe" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(topics:scala.collection.mutable.Set[String],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="subscribe(Set[String],Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscribe(topics:scala.collection.mutable.Set[String],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="topics">topics: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Subscribe to the given list of topics to get dynamically assigned partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribe to the given list of topics to get dynamically assigned partitions.</p><p>Due to internal buffering of messages, when changing the subscribed topics
the old set of topics may remain in effect
(as observed by the  record handler<code>)
until some time <em>after</em> the given </code>completionHandler<code>
is called. In contrast, the once the given </code>completionHandler<code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new set of topics.   * @param topics topics to subscribe to</code></p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscribe" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(topic:String,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="subscribe(String,Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscribe(topic:String,completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="topic">topic: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Subscribe to the given topic to get dynamically assigned partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribe to the given topic to get dynamically assigned partitions.</p><p>Due to internal buffering of messages, when changing the subscribed topic
the old topic may remain in effect
(as observed by the  record handler<code>)
until some time <em>after</em> the given </code>completionHandler<code>
is called. In contrast, the once the given </code>completionHandler<code>
is called the <a href="#batchHandler(handler:io.vertx.core.Handler[io.vertx.scala.kafka.client.consumer.KafkaConsumerRecords[K,V]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler">io.vertx.scala.kafka.client.consumer.KafkaConsumer#batchHandler</a> will only see messages
consistent with the new topic.   * @param topic topic to subscribe to</code></p></div><dl class="paramcmts block"><dt class="param">completionHandler</dt><dd class="cmt"><p>handler called on operation completed</p></dd><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscribe" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(topics:scala.collection.mutable.Set[String]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="subscribe(Set[String]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscribe(topics:scala.collection.mutable.Set[String]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="topics">topics: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Subscribe to the given list of topics to get dynamically assigned partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribe to the given list of topics to get dynamically assigned partitions.   * @param topics topics to subscribe to</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscribe" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscribe(topic:String):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="subscribe(String):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscribe(topic:String):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribe</span><span class="params">(<span name="topic">topic: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Subscribe to the given topic to get dynamically assigned partitions.</p><div class="fullcomment"><div class="comment cmt"><p>Subscribe to the given topic to get dynamically assigned partitions.   * @param topic topic to subscribe to</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscribeFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="subscribeFuture(topics:scala.collection.mutable.Set[String]):scala.concurrent.Future[Unit]"></a><a id="subscribeFuture(Set[String]):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscribeFuture(topics:scala.collection.mutable.Set[String]):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribeFuture</span><span class="params">(<span name="topics">topics: <span class="extype" name="scala.collection.mutable.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#subscribe(topics:scala.collection.mutable.Set[String],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscribe">subscribe</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscribeFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="subscribeFuture(topic:String):scala.concurrent.Future[Unit]"></a><a id="subscribeFuture(String):Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscribeFuture(topic:String):scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscribeFuture</span><span class="params">(<span name="topic">topic: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#subscribe(topics:scala.collection.mutable.Set[String],completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscribe">subscribe</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscription" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subscription(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[String]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="subscription(Handler[AsyncResult[Set[String]]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscription(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[String]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscription</span><span class="params">(<span name="handler">handler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Get the current subscription.</p><div class="fullcomment"><div class="comment cmt"><p>Get the current subscription.   * @param handler handler called on operation completed</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscriptionFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="subscriptionFuture():scala.concurrent.Future[scala.collection.mutable.Set[String]]"></a><a id="subscriptionFuture():Future[Set[String]]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#subscriptionFuture():scala.concurrent.Future[scala.collection.mutable.Set[String]]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">subscriptionFuture</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.collection.mutable.Set">Set</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#subscription(handler:io.vertx.core.Handler[io.vertx.core.AsyncResult[scala.collection.mutable.Set[String]]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#subscription">subscription</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a><a id="synchronized[T0](⇒T0):T0"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#toString():String" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#unsubscribe" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsubscribe(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="unsubscribe(Handler[AsyncResult[Unit]]):KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#unsubscribe(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsubscribe</span><span class="params">(<span name="completionHandler">completionHandler: <span class="extype" name="io.vertx.core.Handler">Handler</span>[<span class="extype" name="io.vertx.core.AsyncResult">AsyncResult</span>[<span class="extype" name="scala.Unit">Unit</span>]]</span>)</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Unsubscribe from topics currently subscribed with subscribe.</p><div class="fullcomment"><div class="comment cmt"><p>Unsubscribe from topics currently subscribed with subscribe.   * @param completionHandler handler called on operation completed</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>current KafkaConsumer instance</p></dd></dl></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#unsubscribe" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unsubscribe():io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]"></a><a id="unsubscribe():KafkaConsumer[K,V]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#unsubscribe():io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsubscribe</span><span class="params">()</span><span class="result">: <a href="" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer">KafkaConsumer</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Unsubscribe from topics currently subscribed with subscribe.</p><div class="fullcomment"><div class="comment cmt"><p>Unsubscribe from topics currently subscribed with subscribe.   * @return current KafkaConsumer instance
</p></div></div>
    </li><li name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#unsubscribeFuture" visbl="pub" class="indented0 " data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="unsubscribeFuture():scala.concurrent.Future[Unit]"></a><a id="unsubscribeFuture():Future[Unit]"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#unsubscribeFuture():scala.concurrent.Future[Unit]" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unsubscribeFuture</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      
      <p class="shortcomment cmt">Like <a href="#unsubscribe(completionHandler:io.vertx.core.Handler[io.vertx.core.AsyncResult[Unit]]):io.vertx.scala.kafka.client.consumer.KafkaConsumer[K,V]" class="extmbr" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer#unsubscribe">unsubscribe</a> but returns a <span class="extype" name="scala.concurrent.Future">scala.concurrent.Future</span> instead of taking an AsyncResultHandler.</p>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#wait():Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a><a id="wait(Long,Int):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" class="indented0 " data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a><a id="wait(Long):Unit"></a>
      <span class="permalink">
      <a href="../../../../../../io/vertx/scala/kafka/client/consumer/KafkaConsumer.html#wait(x$1:Long):Unit" title="Permalink">
        <i class="material-icons"></i>
      </a>
    </span>
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@native</span><span class="args">()</span>
              
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li>
              </ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="io.vertx.scala.core.streams.ReadStream">
              <h3>Inherited from <a href="../../../core/streams/ReadStream.html" class="extype" name="io.vertx.scala.core.streams.ReadStream">ReadStream</a>[<a href="KafkaConsumerRecord.html" class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumerRecord">KafkaConsumerRecord</a>[<span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.K">K</span>, <span class="extype" name="io.vertx.scala.kafka.client.consumer.KafkaConsumer.V">V</span>]]</h3>
            </div><div class="parent" name="io.vertx.scala.core.streams.StreamBase">
              <h3>Inherited from <a href="../../../core/streams/StreamBase.html" class="extype" name="io.vertx.scala.core.streams.StreamBase">StreamBase</a></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
    </body>
          </div>
        </div>
      </div>
    </body>
      </html>
